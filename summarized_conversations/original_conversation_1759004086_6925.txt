{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/extractors/facebook_extractor.py">\n"""\nFacebook data extractor using Facebook Graph API.\nHandles page posts and comments extraction.\n"""\nimport re\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Optional\nimport time\nimport requests\n\nfrom tqdm import tqdm\n\nfrom .base_extractor import BaseExtractor, ExtractionError, RateLimitError, AuthenticationError\nfrom ..config import APIConfig\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nclass FacebookExtractor(BaseExtractor):\n    """Facebook data extractor"""\n    \n    def __init__(self, service: str, max_posts: int = 500):\n        super().__init__(service, max_posts)\n        self.access_token = APIConfig.FACEBOOK_ACCESS_TOKEN\n        self.base_url = "https://graph.facebook.com/v18.0"\n        self._validate_credentials()\n    \n    def _validate_credentials(self):\n        """Validate Facebook API credentials"""\n        if not self.access_token:\n            raise AuthenticationError("Facebook access token not configured")\n        \n        try:\n            # Test API connection\n            test_url = f"{self.base_url}/me"\n            params = {\'access_token\': self.access_token}\n            response = requests.get(test_url, params=params)\n            \n            if response.status_code != 200:\n                raise AuthenticationError(f"Facebook API authentication failed: {response.text}")\n            \n            logger.info("Facebook API authentication successful")\n            \n        except Exception as e:\n            logger.error(f"Facebook API validation failed: {e}")\n            raise AuthenticationError(f"Facebook API validation failed: {e}")\n    \n    def extract_posts(self, days: int = 30, **kwargs) -> List[Dict[str, Any]]:\n        """Extract Facebook posts"""\n        logger.info(f"Extracting Facebook posts for \'{self.service}\' from last {days} days")\n        \n        try:\n            # Search for pages related to the service\n            pages = self._search_pages(self.service)\n            \n            if not pages:\n                logger.warning(f"No Facebook pages found for service: {self.service}")\n                return []\n            \n            all_posts = []\n            for page in pages[:5]:  # Limit to top 5 pages\n                page_posts = self._extract_page_posts(page[\'id\'], days)\n                all_posts.extend(page_posts)\n                \n                if len(all_posts) >= self.max_posts:\n                    break\n            \n            # Limit to max_posts\n            posts = all_posts[:self.max_posts]\n            self.posts_extracted = len(posts)\n            \n            logger.info(f"Extracted {len(posts)} Facebook posts")\n            return posts\n            \n        except Exception as e:\n            self._handle_extraction_error(e, "Facebook extraction")\n            return []\n    \n    def _search_pages(self, query: str) -> List[Dict[str, Any]]:\n        """Search Facebook pages"""\n        pages = []\n        \n        try:\n            search_url = f"{self.base_url}/search"\n            params = {\n                \'q\': query,\n                \'type\': \'page\',\n                \'fields\': \'id,name,username,link,fan_count,rating_count\',\n                \'access_token\': self.access_token,\n                \'limit\': 10\n            }\n            \n            response = requests.get(search_url, params=params)\n            \n            if response.status_code == 200:\n                data = response.json()\n                pages = data.get(\'data\', [])\n                \n                # Sort by fan count (popularity)\n                pages.sort(key=lambda x: x.get(\'fan_count\', 0), reverse=True)\n                \n                logger.info(f"Found {len(pages)} Facebook pages for query: {query}")\n            else:\n                logger.error(f"Facebook search error: {response.text}")\n                \n        except Exception as e:\n            logger.error(f"Error searching Facebook pages: {e}")\n        \n        return pages\n    \n    def _extract_page_posts(self, page_id: str, days: int) -> List[Dict[str, Any]]:\n        """Extract posts from a Facebook page"""\n        posts = []\n        start_date, end_date = self._calculate_date_range(days)\n        \n        try:\n            posts_url = f"{self.base_url}/{page_id}/posts"\n            params = {\n                \'fields\': \'id,message,created_time,likes.summary(true),\'\n                         \'comments.summary(true),shares,permalink_url,\'\n                         \'reactions.summary(true)\',\n                \'access_token\': self.access_token,\n                \'limit\': 100,\n                \'since\': start_date.isoformat(),\n                \'until\': end_date.isoformat()\n            }\n            \n            while len(posts) < self.max_posts:\n                response = requests.get(posts_url, params=params)\n                \n                if response.status_code != 200:\n                    logger.error(f"Facebook API error: {response.text}")\n                    break\n                \n                data = response.json()\n                page_posts = data.get(\'data\', [])\n                \n                if not page_posts:\n                    break\n                \n                for post in page_posts:\n                    processed_post = self._process_page_post(post)\n                    if processed_post:\n                        posts.append(processed_post)\n                        self.posts_extracted += 1\n                    \n                    if len(posts) >= self.max_posts:\n                        break\n                \n                # Check for next page\n                paging = data.get(\'paging\', {})\n                if \'next\' in paging:\n                    posts_url = paging[\'next\']\n                    params = {}  # URL already contains params\n                else:\n                    break\n                \n                # Rate limiting\n                self._rate_limit_delay(1.0)\n                \n        except Exception as e:\n            logger.error(f"Error extracting page posts: {e}")\n        \n        return posts\n    \n    def _process_page_post(self, post: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        """Process Facebook page post"""\n        try:\n            # Extract metrics\n            likes = post.get(\'likes\', {}).get(\'summary\', {}).get(\'total_count\', 0)\n            comments = post.get(\'comments\', {}).get(\'summary\', {}).get(\'total_count\', 0)\n            shares = post.get(\'shares\', {}).get(\'count\', 0) if post.get(\'shares\') else 0\n            reactions = post.get(\'reactions\', {}).get(\'summary\', {}).get(\'total_count\', 0)\n            \n            post_data = {\n                \'id\': post[\'id\'],\n                \'text\': post.get(\'message\', \'\'),\n                \'created_at\': post[\'created_time\'],\n                \'likes\': likes,\n                \'comments\': comments,\n                \'shares\': shares,\n                \'reactions\': reactions,\n                \'permalink_url\': post.get(\'permalink_url\', \'\'),\n                \'type\': \'page_post\'\n            }\n            \n            # Validate and clean\n            validated_post = self._validate_and_clean_post(post_data)\n            if validated_post:\n                return self._normalize_post_structure(validated_post, \'facebook\')\n            \n        except Exception as e:\n            logger.error(f"Error processing Facebook post: {e}")\n            self.errors_count += 1\n        \n        return None\n    \n    def extract_page_reviews(self, page_id: str, days: int = 30) -> List[Dict[str, Any]]:\n        """Extract reviews from a Facebook page"""\n        reviews = []\n        start_date, end_date = self._calculate_date_range(days)\n        \n        try:\n            reviews_url = f"{self.base_url}/{page_id}/ratings"\n            params = {\n                \'fields\': \'review_text,rating,created_time,reviewer\',\n                \'access_token\': self.access_token,\n                \'limit\': 100\n            }\n            \n            response = requests.get(reviews_url, params=params)\n            \n            if response.status_code == 200:\n                data = response.json()\n                page_reviews = data.get(\'data\', [])\n                \n                for review in page_reviews:\n                    processed_review = self._process_review(review)\n                    if processed_review:\n                        # Check if review is within date range\n                        review_date = datetime.fromisoformat(\n                            processed_review[\'created_at\'].replace(\'Z\', \'+00:00\')\n                        )\n                        \n                        if start_date <= review_date <= end_date:\n                            reviews.append(processed_review)\n                            self.posts_extracted += 1\n                \n                logger.info(f"Extracted {len(reviews)} reviews from page {page_id}")\n            \n        except Exception as e:\n            logger.error(f"Error extracting page reviews: {e}")\n        \n        return reviews\n    \n    def _process_review(self, review: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        """Process Facebook review"""\n        try:\n            review_data = {\n                \'id\': review[\'id\'],\n                \'text\': review.get(\'review_text\', \'\'),\n                \'created_at\': review[\'created_time\'],\n                \'rating\': review.get(\'rating\', 0),\n                \'reviewer\': review.get(\'reviewer\', {}),\n                \'type\': \'review\'\n            }\n            \n            # Validate and clean\n            validated_review = self._validate_and_clean_post(review_data)\n            if validated_review:\n                return self._normalize_post_structure(validated_review, \'facebook\')\n            \n        except Exception as e:\n            logger.error(f"Error processing Facebook review: {e}")\n            self.errors_count += 1\n        \n        return None\n    \n    def search_posts(self, query: str, max_results: int = 100) -> List[Dict[str, Any]]:\n        """Search for Facebook posts"""\n        posts = []\n        \n        try:\n            # Search for pages first\n            pages = self._search_pages(query)\n            \n            for page in pages[:3]:  # Limit to top 3 pages\n                page_posts = self._extract_page_posts(page[\'id\'], 30)  # Last 30 days\n                \n                # Filter posts containing the query\n                for post in page_posts:\n                    if query.lower() in post.get(\'text\', \'\').lower():\n                        posts.append(post)\n                    \n                    if len(posts) >= max_results:\n                        break\n                \n                if len(posts) >= max_results:\n                    break\n            \n        except Exception as e:\n            logger.error(f"Facebook search error: {e}")\n            self._handle_extraction_error(e, "Facebook search")\n        \n        return posts[:max_results]\n    \n    def get_post_by_id(self, post_id: str) -> Optional[Dict[str, Any]]:\n        """Get Facebook post by ID"""\n        try:\n            post_url = f"{self.base_url}/{post_id}"\n            params = {\n                \'fields\': \'id,message,created_time,likes.summary(true),\'\n                         \'comments.summary(true),shares,permalink_url\',\n                \'access_token\': self.access_token\n            }\n            \n            response = requests.get(post_url, params=params)\n            \n            if response.status_code == 200:\n                post = response.json()\n                return self._process_page_post(post)\n            \n        except Exception as e:\n            logger.error(f"Error getting Facebook post {post_id}: {e}")\n            self._handle_extraction_error(e, f"Get Facebook post {post_id}")\n        \n        return None\n</create-file>\n</function_calls>'}