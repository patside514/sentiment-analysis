{'role': 'assistant', 'content': 'Maintenant, créons le module d\'extraction de base et les extracteurs spécifiques pour chaque plateforme.\n\n<function_calls>\n<create-file file_path="src/extractors/base_extractor.py">\n"""\nBase extractor class for social media data extraction.\nProvides common functionality and interface for all extractors.\n"""\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Optional, Iterator\nimport time\n\nfrom ..utils.logger import get_logger\nfrom ..utils.data_validator import DataValidator\nfrom ..config import APIConfig, AnalysisConfig\n\nlogger = get_logger(__name__)\n\nclass BaseExtractor(ABC):\n    """Abstract base class for social media extractors"""\n    \n    def __init__(self, service: str, max_posts: int = 500):\n        self.service = service\n        self.max_posts = max_posts\n        self.validator = DataValidator()\n        self.posts_extracted = 0\n        self.errors_count = 0\n        \n    @abstractmethod\n    def extract_posts(self, days: int = 30, **kwargs) -> List[Dict[str, Any]]:\n        """Extract posts from the social media platform"""\n        pass\n    \n    @abstractmethod\n    def search_posts(self, query: str, max_results: int = 100) -> List[Dict[str, Any]]:\n        """Search for specific posts"""\n        pass\n    \n    @abstractmethod\n    def get_post_by_id(self, post_id: str) -> Optional[Dict[str, Any]]:\n        """Get a specific post by ID"""\n        pass\n    \n    def _calculate_date_range(self, days: int) -> tuple:\n        """Calculate start and end dates for extraction"""\n        end_date = datetime.now()\n        start_date = end_date - timedelta(days=days)\n        return start_date, end_date\n    \n    def _rate_limit_delay(self, delay_seconds: float = 1.0):\n        """Implement rate limiting delay"""\n        time.sleep(delay_seconds)\n    \n    def _validate_and_clean_post(self, post: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        """Validate and clean a post before returning"""\n        try:\n            # Basic validation\n            if not post or not isinstance(post, dict):\n                return None\n            \n            # Extract text content\n            text = (post.get(\'text\') or \n                   post.get(\'message\') or \n                   post.get(\'content\', \'\'))\n            \n            if not self.validator.validate_text_content(text):\n                return None\n            \n            # Clean text\n            post[\'cleaned_text\'] = self.validator.clean_text(text)\n            \n            # Ensure required fields\n            required_fields = [\'id\', \'created_at\', \'text\']\n            for field in required_fields:\n                if field not in post or not post[field]:\n                    return None\n            \n            return post\n            \n        except Exception as e:\n            logger.error(f"Error validating post: {e}")\n            self.errors_count += 1\n            return None\n    \n    def _normalize_post_structure(self, post: Dict[str, Any], \n                                 source: str) -> Dict[str, Any]:\n        """Normalize post structure across different platforms"""\n        normalized = {\n            \'id\': str(post.get(\'id\', \'\')),\n            \'source\': source,\n            \'service\': self.service,\n            \'text\': post.get(\'text\', post.get(\'message\', post.get(\'content\', \'\'))),\n            \'cleaned_text\': post.get(\'cleaned_text\', \'\'),\n            \'created_at\': post.get(\'created_at\', post.get(\'created_time\', datetime.now().isoformat())),\n            \'author\': post.get(\'author\', post.get(\'user\', post.get(\'from\', {}))),\n            \'likes\': post.get(\'likes\', post.get(\'reactions\', {}).get(\'like\', 0)),\n            \'shares\': post.get(\'shares\', post.get(\'retweets\', 0)),\n            \'comments\': post.get(\'comments\', 0),\n            \'url\': post.get(\'url\', post.get(\'permalink_url\', \'\')),\n            \'metadata\': {\n                \'raw_data\': post,\n                \'extraction_date\': datetime.now().isoformat(),\n                \'source_platform\': source\n            }\n        }\n        \n        return normalized\n    \n    def _handle_extraction_error(self, error: Exception, context: str):\n        """Handle and log extraction errors"""\n        logger.error(f"Extraction error in {context}: {str(error)}")\n        self.errors_count += 1\n    \n    def get_extraction_stats(self) -> Dict[str, Any]:\n        """Get extraction statistics"""\n        return {\n            \'service\': self.service,\n            \'posts_extracted\': self.posts_extracted,\n            \'errors_count\': self.errors_count,\n            \'success_rate\': (self.posts_extracted / (self.posts_extracted + self.errors_count) * 100) \n                           if (self.posts_extracted + self.errors_count) > 0 else 0\n        }\n\nclass ExtractionError(Exception):\n    """Custom exception for extraction errors"""\n    pass\n\nclass RateLimitError(Exception):\n    """Custom exception for rate limit errors"""\n    pass\n\nclass AuthenticationError(Exception):\n    """Custom exception for authentication errors"""\n    pass\n</create-file>\n</function_calls>'}