{'role': 'assistant', 'content': 'Maintenant, créons l\'interface CLI et le point d\'entrée principal de l\'application.\n\n<function_calls>\n<create-file file_path="src/cli.py">\n"""\nCommand-line interface for the social media sentiment analysis application.\nHandles argument parsing, validation, and user interaction.\n"""\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional\n\nimport click\nfrom colorama import init, Fore, Style\nfrom tqdm import tqdm\n\nfrom .config import AVAILABLE_SOURCES, DEFAULT_SOURCE, AnalysisConfig\nfrom .utils.logger import get_logger, app_logger\nfrom .utils.data_validator import validate_cli_args\nfrom .utils.file_manager import FileManager\n\n# Initialize colorama for cross-platform colored output\ninit(autoreset=True)\n\nlogger = get_logger(__name__)\n\nclass ColoredFormatter:\n    """Color formatter for CLI output"""\n    \n    COLORS = {\n        \'info\': Fore.BLUE,\n        \'success\': Fore.GREEN,\n        \'warning\': Fore.YELLOW,\n        \'error\': Fore.RED,\n        \'bold\': Style.BRIGHT,\n        \'reset\': Style.RESET_ALL\n    }\n    \n    @staticmethod\n    def colorize(text: str, color: str) -> str:\n        """Apply color to text"""\n        return f"{ColoredFormatter.COLORS.get(color, \'\')}{text}{ColoredFormatter.COLORS[\'reset\']}"\n    \n    @staticmethod\n    def print colored(text: str, color: str = \'info\'):\n        """Print colored text"""\n        click.echo(ColoredFormatter.colorize(text, color))\n\n@click.command()\n@click.option(\'--service\', \'-s\', \n              required=True,\n              help=\'Service or brand name to analyze (e.g., "Uber", "Netflix")\')\n@click.option(\'--source\', \'-src\',\n              type=click.Choice(AVAILABLE_SOURCES, case_sensitive=False),\n              default=DEFAULT_SOURCE,\n              help=\'Social media source to analyze\')\n@click.option(\'--days\', \'-d\',\n              type=click.IntRange(1, 60),\n              default=AnalysisConfig.DEFAULT_DAYS,\n              help=\'Number of days to analyze (1-60)\')\n@click.option(\'--max-posts\', \'-m\',\n              type=click.IntRange(AnalysisConfig.MIN_POSTS, AnalysisConfig.MAX_POSTS),\n              default=AnalysisConfig.MAX_POSTS,\n              help=f\'Maximum number of posts to extract ({AnalysisConfig.MIN_POSTS}-{AnalysisConfig.MAX_POSTS})\')\n@click.option(\'--output-dir\', \'-o\',\n              type=click.Path(path_type=Path),\n              default=None,\n              help=\'Output directory for results\')\n@click.option(\'--format\', \'-f\',\n              type=click.Choice([\'csv\', \'json\', \'html\', \'all\'], case_sensitive=False),\n              default=\'all\',\n              help=\'Output format for results\')\n@click.option(\'--language\', \'-l\',\n              type=click.Choice([\'auto\', \'fr\', \'en\'], case_sensitive=False),\n              default=\'auto\',\n              help=\'Language for analysis (auto-detection by default)\')\n@click.option(\'--sentiment-model\', \'-sm\',\n              type=click.Choice([\'auto\', \'textblob\', \'transformers\'], case_sensitive=False),\n              default=\'auto\',\n              help=\'Sentiment analysis model to use\')\n@click.option(\'--keyword-method\', \'-km\',\n              type=click.Choice([\'tfidf\', \'frequency\', \'textrank\', \'combined\'], case_sensitive=False),\n              default=\'combined\',\n              help=\'Keyword extraction method\')\n@click.option(\'--verbose\', \'-v\',\n              is_flag=True,\n              help=\'Enable verbose output\')\n@click.option(\'--quiet\', \'-q\',\n              is_flag=True,\n              help=\'Suppress non-error output\')\n@click.option(\'--config-file\', \'-c\',\n              type=click.Path(exists=True, path_type=Path),\n              help=\'Configuration file path\')\n@click.option(\'--dry-run\', \'-dr\',\n              is_flag=True,\n              help=\'Perform a dry run without actual data extraction\')\n@click.version_option(version=\'1.0.0\', prog_name=\'Social Media Sentiment Analyzer\')\n\ndef main(service: str, source: str, days: int, max_posts: int, output_dir: Optional[Path],\n         format: str, language: str, sentiment_model: str, keyword_method: str,\n         verbose: bool, quiet: bool, config_file: Optional[Path], dry_run: bool):\n    """\n    Social Media Sentiment Analysis Tool\n    \n    Extract and analyze sentiment from social media posts about a specific service or brand.\n    \n    Example usage:\n    \n    \\b\n        python app.py --service "Uber" --source "twitter" --days 30\n        python app.py -s "Netflix" -src "facebook" -d 15 -m 200\n        python app.py --service "Airbnb" --source "google_reviews" --format html\n    """\n    \n    # Setup logging based on verbosity\n    if quiet:\n        app_logger.logger.setLevel(\'ERROR\')\n    elif verbose:\n        app_logger.logger.setLevel(\'DEBUG\')\n    else:\n        app_logger.logger.setLevel(\'INFO\')\n    \n    # Print banner\n    if not quiet:\n        print_banner()\n    \n    # Validate inputs\n    validation_result = validate_cli_args(service, source, days, max_posts)\n    \n    if not validation_result[\'valid\']:\n        error_msg = "Validation errors:\\n" + "\\n".join(f"  - {error}" for error in validation_result[\'errors\'])\n        click.echo(ColoredFormatter.colorize(error_msg, \'error\'), err=True)\n        sys.exit(1)\n    \n    # Use cleaned values\n    cleaned_args = validation_result[\'cleaned\']\n    service = cleaned_args[\'service\']\n    source = cleaned_args[\'source\']\n    \n    # Print configuration summary\n    if not quiet:\n        print_configuration(service, source, days, max_posts, output_dir, format, \n                          language, sentiment_model, keyword_method, config_file)\n    \n    # Confirm before proceeding (unless quiet mode)\n    if not quiet and not dry_run:\n        if not click.confirm(ColoredFormatter.colorize("Proceed with analysis?", \'info\')):\n            click.echo(ColoredFormatter.colorize("Analysis cancelled by user.", \'warning\'))\n            sys.exit(0)\n    \n    # Perform dry run if requested\n    if dry_run:\n        perform_dry_run(service, source, days, max_posts, output_dir, format,\n                       language, sentiment_model, keyword_method)\n        return\n    \n    # Run analysis\n    try:\n        success = run_analysis(service, source, days, max_posts, output_dir, format,\n                             language, sentiment_model, keyword_method, quiet)\n        \n        if success:\n            if not quiet:\n                click.echo(ColoredFormatter.colorize("✅ Analysis completed successfully!", \'success\'))\n            sys.exit(0)\n        else:\n            if not quiet:\n                click.echo(ColoredFormatter.colorize("❌ Analysis failed!", \'error\'), err=True)\n            sys.exit(1)\n            \n    except KeyboardInterrupt:\n        if not quiet:\n            click.echo(ColoredFormatter.colorize("\\n⚠️ Analysis interrupted by user.", \'warning\'))\n        sys.exit(130)\n    \n    except Exception as e:\n        logger.error(f"Unexpected error during analysis: {e}")\n        if not quiet:\n            click.echo(ColoredFormatter.colorize(f"❌ Unexpected error: {e}", \'error\'), err=True)\n        sys.exit(1)\n\ndef print_banner():\n    """Print application banner"""\n    banner = """\n    ╔═══════════════════════════════════════════════════════════════════════╗\n    ║                                                                       ║\n    ║  🚀 Social Media Sentiment Analysis Tool 🚀                          ║\n    ║                                                                       ║\n    ║  Extract and analyze sentiment from social media platforms            ║\n    ║  Powered by NLP and Machine Learning                                  ║\n    ║                                                                       ║\n    ╚═══════════════════════════════════════════════════════════════════════╝\n    """\n    click.echo(ColoredFormatter.colorize(banner, \'info\'))\n    click.echo()\n\ndef print_configuration(service: str, source: str, days: int, max_posts: int,\n                       output_dir: Optional[Path], format: str, language: str,\n                       sentiment_model: str, keyword_method: str, config_file: Optional[Path]):\n    """Print configuration summary"""\n    config_text = f"""\n    📋 Configuration Summary:\n    \n    🔍 Analysis Parameters:\n       Service: {ColoredFormatter.colorize(service, \'bold\')}\n       Source: {ColoredFormatter.colorize(source.upper(), \'bold\')}\n       Time Period: {ColoredFormatter.colorize(f\'{days} days\', \'info\')}\n       Max Posts: {ColoredFormatter.colorize(str(max_posts), \'info\')}\n    \n    ⚙️ Processing Options:\n       Language: {ColoredFormatter.colorize(language, \'info\')}\n       Sentiment Model: {ColoredFormatter.colorize(sentiment_model, \'info\')}\n       Keyword Method: {ColoredFormatter.colorize(keyword_method, \'info\')}\n       Output Format: {ColoredFormatter.colorize(format.upper(), \'info\')}\n    """\n    \n    if output_dir:\n        config_text += f"\\n       Output Directory: {ColoredFormatter.colorize(str(output_dir), \'info\')}"\n    \n    if config_file:\n        config_text += f"\\n       Config File: {ColoredFormatter.colorize(str(config_file), \'info\')}"\n    \n    click.echo(config_text)\n    click.echo()\n\ndef perform_dry_run(service: str, source: str, days: int, max_posts: int,\n                   output_dir: Optional[Path], format: str, language: str,\n                   sentiment_model: str, keyword_method: str):\n    """Perform dry run simulation"""\n    click.echo(ColoredFormatter.colorize("\\n🔍 DRY RUN MODE - Simulation Only\\n", \'warning\'))\n    \n    # Simulate analysis steps\n    steps = [\n        "Validating input parameters",\n        "Checking API credentials",\n        "Estimating data volume",\n        "Preparing analysis pipeline",\n        "Generating output preview"\n    ]\n    \n    with tqdm(total=len(steps), desc="Simulating analysis", unit="step") as pbar:\n        for step in steps:\n            pbar.set_description(f"Simulating: {step}")\n            time.sleep(0.5)  # Simulate processing time\n            pbar.update(1)\n    \n    # Show preview of what would be generated\n    click.echo(f"\\n{ColoredFormatter.colorize(\'📊 Expected Output Preview:\', \'info\')}")\n    click.echo(f"   • CSV files with raw and processed data")\n    click.echo(f"   • Sentiment analysis results")\n    click.echo(f"   • Keyword extraction results")\n    click.echo(f"   • Visualization charts (pie, bar, trend)")\n    click.echo(f"   • Word clouds")\n    click.echo(f"   • Comprehensive HTML report")\n    \n    click.echo(f"\\n{ColoredFormatter.colorize(\'✅ Dry run completed successfully!\', \'success\')}")\n    click.echo(f"   Run without --dry-run to perform actual analysis.")\n\ndef run_analysis(service: str, source: str, days: int, max_posts: int,\n                output_dir: Optional[Path], format: str, language: str,\n                sentiment_model: str, keyword_method: str, quiet: bool) -> bool:\n    """Run the actual analysis"""\n    from .main import SocialMediaAnalyzer\n    \n    try:\n        # Initialize analyzer\n        analyzer = SocialMediaAnalyzer()\n        \n        # Set output directory\n        if output_dir:\n            file_manager = FileManager(output_dir)\n        else:\n            file_manager = FileManager()\n        \n        # Run analysis with progress tracking\n        if not quiet:\n            click.echo(ColoredFormatter.colorize("\\n🚀 Starting analysis...", \'info\'))\n        \n        results = analyzer.analyze(\n            service=service,\n            source=source,\n            days=days,\n            max_posts=max_posts,\n            language=language,\n            sentiment_model=sentiment_model,\n            keyword_method=keyword_method,\n            progress_callback=lambda msg: logger.info(msg) if not quiet else None\n        )\n        \n        if not results:\n            logger.error("Analysis returned no results")\n            return False\n        \n        # Save results\n        if not quiet:\n            click.echo(ColoredFormatter.colorize("\\n💾 Saving results...", \'info\'))\n        \n        output_path = file_manager.save_analysis_report(results, service, source)\n        \n        # Generate additional formats if requested\n        if format != \'csv\':  # CSV is already included in the analysis report\n            if not quiet:\n                click.echo(ColoredFormatter.colorize(f"\\n📄 Generating {format.upper()} report...", \'info\'))\n            \n            if format in [\'html\', \'all\']:\n                from .visualization.report_generator import ReportGenerator\n                report_gen = ReportGenerator()\n                html_path = report_gen.generate_html_report(results, service, source)\n                if html_path and not quiet:\n                    click.echo(ColoredFormatter.colorize(f"   HTML report: {html_path}", \'success\'))\n        \n        if not quiet:\n            click.echo(f"\\n{ColoredFormatter.colorize(\'📁 Results saved to:\', \'info\')} {output_path}")\n            click.echo(f"   {ColoredFormatter.colorize(\'Service:\', \'info\')} {service}")\n            click.echo(f"   {ColoredFormatter.colorize(\'Source:\', \'info\')} {source}")\n            click.echo(f"   {ColoredFormatter.colorize(\'Posts analyzed:\', \'info\')} {results.get(\'sentiment_summary\', {}).get(\'total\', 0)}")\n        \n        return True\n        \n    except Exception as e:\n        logger.error(f"Analysis failed: {e}")\n        if not quiet:\n            click.echo(ColoredFormatter.colorize(f"❌ Analysis failed: {e}", \'error\'), err=True)\n        return False\n\nif __name__ == \'__main__\':\n    main()\n</create-file>\n</function_calls>'}