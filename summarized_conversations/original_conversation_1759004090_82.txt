{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/nlp/sentiment_analyzer.py">\n"""\nSentiment analysis module using multiple approaches.\nSupports TextBlob, Transformers, and custom models.\n"""\nfrom typing import Dict, Any, List, Optional, Tuple\nimport numpy as np\n\ntry:\n    from textblob import TextBlob\n    TEXTBLOB_AVAILABLE = True\nexcept ImportError:\n    TEXTBLOB_AVAILABLE = False\n\ntry:\n    from transformers import pipeline, AutoTokenizer, AutoModelForSequenceClassification\n    TRANSFORMERS_AVAILABLE = True\nexcept ImportError:\n    TRANSFORMERS_AVAILABLE = False\n\nfrom ..utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nclass SentimentAnalyzer:\n    """Multi-model sentiment analyzer"""\n    \n    def __init__(self, model_type: str = \'auto\', language: str = \'auto\'):\n        self.model_type = model_type\n        self.language = language\n        self.models = {}\n        self._setup_models()\n    \n    def _setup_models(self):\n        """Setup sentiment analysis models"""\n        try:\n            if TRANSFORMERS_AVAILABLE:\n                # Setup multilingual transformer model\n                self.models[\'transformers\'] = pipeline(\n                    "sentiment-analysis",\n                    model="cardiffnlp/twitter-roberta-base-sentiment-latest",\n                    tokenizer="cardiffnlp/twitter-roberta-base-sentiment-latest"\n                )\n                logger.info("Transformers sentiment model loaded")\n            \n            if TEXTBLOB_AVAILABLE:\n                logger.info("TextBlob sentiment analysis available")\n            \n        except Exception as e:\n            logger.error(f"Error setting up sentiment models: {e}")\n    \n    def analyze_sentiment(self, text: str, language: Optional[str] = None) -> Dict[str, Any]:\n        """Analyze sentiment of a single text"""\n        if not text or not isinstance(text, str):\n            return self._get_neutral_result()\n        \n        try:\n            lang = language or self.language or self._detect_language(text)\n            \n            # Choose analysis method\n            if self.model_type == \'transformers\' and TRANSFORMERS_AVAILABLE:\n                result = self._analyze_with_transformers(text)\n            elif lang == \'french\' and TEXTBLOB_AVAILABLE:\n                result = self._analyze_with_textblob_fr(text)\n            else:\n                result = self._analyze_with_textblob_en(text)\n            \n            # Add metadata\n            result.update({\n                \'text\': text[:100] + \'...\' if len(text) > 100 else text,\n                \'language\': lang,\n                \'model_used\': self.model_type\n            })\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f"Sentiment analysis error: {e}")\n            return self._get_neutral_result()\n    \n    def analyze_batch(self, texts: List[str], language: Optional[str] = None) -> List[Dict[str, Any]]:\n        """Analyze sentiment for multiple texts"""\n        results = []\n        \n        for text in texts:\n            result = self.analyze_sentiment(text, language)\n            results.append(result)\n        \n        return results\n    \n    def _analyze_with_transformers(self, text: str) -> Dict[str, Any]:\n        """Analyze sentiment using Transformers"""\n        try:\n            # Truncate text if too long\n            max_length = 512\n            if len(text) > max_length:\n                text = text[:max_length]\n            \n            result = self.models[\'transformers\'](text)[0]\n            \n            label = result[\'label\'].lower()\n            score = result[\'score\']\n            \n            # Map to standard sentiment\n            if \'positive\' in label:\n                sentiment = \'positive\'\n                polarity = score\n            elif \'negative\' in label:\n                sentiment = \'negative\'\n                polarity = -score\n            else:\n                sentiment = \'neutral\'\n                polarity = 0\n            \n            return {\n                \'sentiment\': sentiment,\n                \'polarity\': polarity,\n                \'confidence\': score,\n                \'raw_label\': result[\'label\'],\n                \'method\': \'transformers\'\n            }\n            \n        except Exception as e:\n            logger.error(f"Transformers analysis error: {e}")\n            return self._analyze_with_textblob_en(text)  # Fallback\n    \n    def _analyze_with_textblob_en(self, text: str) -> Dict[str, Any]:\n        """Analyze sentiment using TextBlob (English)"""\n        if not TEXTBLOB_AVAILABLE:\n            return self._get_neutral_result()\n        \n        try:\n            blob = TextBlob(text)\n            polarity = blob.sentiment.polarity\n            subjectivity = blob.sentiment.subjectivity\n            \n            # Classify sentiment\n            if polarity > 0.1:\n                sentiment = \'positive\'\n            elif polarity < -0.1:\n                sentiment = \'negative\'\n            else:\n                sentiment = \'neutral\'\n            \n            return {\n                \'sentiment\': sentiment,\n                \'polarity\': polarity,\n                \'subjectivity\': subjectivity,\n                \'confidence\': abs(polarity),\n                \'method\': \'textblob_en\'\n            }\n            \n        except Exception as e:\n            logger.error(f"TextBlob English analysis error: {e}")\n            return self._get_neutral_result()\n    \n    def _analyze_with_textblob_fr(self, text: str) -> Dict[str, Any]:\n        """Analyze sentiment using TextBlob (French)"""\n        if not TEXTBLOB_AVAILABLE:\n            return self._get_neutral_result()\n        \n        try:\n            # TextBlob\'s French sentiment analysis is limited\n            # We\'ll use a simple approach with translation or fallback\n            \n            blob = TextBlob(text)\n            polarity = blob.sentiment.polarity\n            \n            # For French, we adjust the thresholds slightly\n            if polarity > 0.15:\n                sentiment = \'positive\'\n            elif polarity < -0.15:\n                sentiment = \'negative\'\n            else:\n                sentiment = \'neutral\'\n            \n            return {\n                \'sentiment\': sentiment,\n                \'polarity\': polarity,\n                \'subjectivity\': blob.sentiment.subjectivity,\n                \'confidence\': abs(polarity),\n                \'method\': \'textblob_fr\'\n            }\n            \n        except Exception as e:\n            logger.error(f"TextBlob French analysis error: {e}")\n            return self._get_neutral_result()\n    \n    def _detect_language(self, text: str) -> str:\n        """Simple language detection for sentiment analysis"""\n        # Simple heuristic based on common words\n        french_words = [\'le\', \'la\', \'les\', \'un\', \'une\', \'de\', \'du\', \'des\', \'et\', \'est\', \'sont\']\n        english_words = [\'the\', \'and\', \'is\', \'are\', \'in\', \'on\', \'at\', \'to\', \'for\', \'of\']\n        \n        text_lower = text.lower()\n        \n        french_score = sum(1 for word in french_words if word in text_lower)\n        english_score = sum(1 for word in english_words if word in text_lower)\n        \n        if french_score > english_score:\n            return \'french\'\n        else:\n            return \'english\'\n    \n    def _get_neutral_result(self) -> Dict[str, Any]:\n        """Return neutral sentiment result"""\n        return {\n            \'sentiment\': \'neutral\',\n            \'polarity\': 0.0,\n            \'subjectivity\': 0.0,\n            \'confidence\': 0.0,\n            \'method\': \'fallback\',\n            \'error\': \'Analysis failed\'\n        }\n    \n    def get_sentiment_summary(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:\n        """Get summary statistics for sentiment analysis results"""\n        if not results:\n            return {\n                \'total\': 0,\n                \'positive\': 0,\n                \'negative\': 0,\n                \'neutral\': 0,\n                \'percentages\': {\n                    \'positive\': 0,\n                    \'negative\': 0,\n                    \'neutral\': 0\n                },\n                \'average_polarity\': 0.0,\n                \'average_confidence\': 0.0\n            }\n        \n        total = len(results)\n        positive = sum(1 for r in results if r[\'sentiment\'] == \'positive\')\n        negative = sum(1 for r in results if r[\'sentiment\'] == \'negative\')\n        neutral = sum(1 for r in results if r[\'sentiment\'] == \'neutral\')\n        \n        avg_polarity = np.mean([r[\'polarity\'] for r in results])\n        avg_confidence = np.mean([r.get(\'confidence\', 0) for r in results])\n        \n        return {\n            \'total\': total,\n            \'positive\': positive,\n            \'negative\': negative,\n            \'neutral\': neutral,\n            \'percentages\': {\n                \'positive\': round(positive / total * 100, 2),\n                \'negative\': round(negative / total * 100, 2),\n                \'neutral\': round(neutral / total * 100, 2)\n            },\n            \'average_polarity\': round(avg_polarity, 3),\n            \'average_confidence\': round(avg_confidence, 3)\n        }\n\nclass SentimentTrendAnalyzer:\n    """Analyze sentiment trends over time"""\n    \n    def __init__(self, analyzer: SentimentAnalyzer):\n        self.analyzer = analyzer\n    \n    def analyze_temporal_trends(self, texts: List[str], dates: List[str]) -> Dict[str, Any]:\n        """Analyze sentiment trends over time"""\n        if len(texts) != len(dates):\n            raise ValueError("Texts and dates lists must have the same length")\n        \n        # Combine and sort by date\n        dated_texts = list(zip(dates, texts))\n        dated_texts.sort(key=lambda x: x[0])\n        \n        # Analyze sentiment for each text\n        results = []\n        for date, text in dated_texts:\n            sentiment_result = self.analyzer.analyze_sentiment(text)\n            sentiment_result[\'date\'] = date\n            results.append(sentiment_result)\n        \n        # Group by date intervals\n        trends = self._group_by_date_intervals(results)\n        \n        return {\n            \'detailed_results\': results,\n            \'trends_by_interval\': trends,\n            \'overall_trend\': self._calculate_overall_trend(results)\n        }\n    \n    def _group_by_date_intervals(self, results: List[Dict[str, Any]], \n                                interval_days: int = 7) -> Dict[str, Any]:\n        """Group sentiment results by date intervals"""\n        from datetime import datetime, timedelta\n        \n        if not results:\n            return {}\n        \n        # Parse dates\n        dated_results = []\n        for result in results:\n            try:\n                date = datetime.fromisoformat(result[\'date\'].replace(\'Z\', \'+00:00\'))\n                dated_results.append((date, result))\n            except Exception:\n                continue\n        \n        if not dated_results:\n            return {}\n        \n        # Sort by date\n        dated_results.sort(key=lambda x: x[0])\n        \n        # Group by intervals\n        start_date = dated_results[0][0]\n        end_date = dated_results[-1][0]\n        \n        intervals = {}\n        current_date = start_date\n        \n        while current_date <= end_date:\n            interval_end = current_date + timedelta(days=interval_days)\n            interval_key = current_date.strftime("%Y-%m-%d")\n            \n            interval_results = [\n                result for date, result in dated_results\n                if current_date <= date < interval_end\n            ]\n            \n            if interval_results:\n                interval_summary = self.analyzer.get_sentiment_summary(interval_results)\n                intervals[interval_key] = interval_summary\n            \n            current_date = interval_end\n        \n        return intervals\n    \n    def _calculate_overall_trend(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:\n        """Calculate overall sentiment trend"""\n        if not results:\n            return {\'direction\': \'stable\', \'strength\': 0}\n        \n        # Calculate trend based on polarity changes\n        polarities = [r[\'polarity\'] for r in results]\n        \n        if len(polarities) < 2:\n            return {\'direction\': \'stable\', \'strength\': 0}\n        \n        # Simple linear trend\n        x = list(range(len(polarities)))\n        y = polarities\n        \n        # Calculate correlation coefficient\n        correlation = np.corrcoef(x, y)[0, 1]\n        \n        if correlation > 0.3:\n            direction = \'improving\'\n        elif correlation < -0.3:\n            direction = \'declining\'\n        else:\n            direction = \'stable\'\n        \n        return {\n            \'direction\': direction,\n            \'strength\': abs(correlation),\n            \'correlation\': correlation\n        }\n</create-file>\n</function_calls>'}